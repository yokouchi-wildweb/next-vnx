# ゲームアーキテクチャ概要 v2

## 用語定義

### ストーリー階層

```
Chapter（チャプター）── ストーリー上のまとまり
  └─ Scene（シーン）── 画面レイアウト・機能が固定される単位
       └─ Fragment（フラグメント）── シーン内のローカル遷移単位
            └─ Node（ノード）── 1台詞・1コマンド（最小単位）
```

| 用語 | 説明 | 例 |
|------|------|-----|
| Chapter | ストーリーの章 | 「第1章：出会い」 |
| Scene | シーンタイプ・レイアウトが固定 | 「教室での会話」 |
| Fragment | 選択肢分岐の単位、セーブ粒度 | 「導入」「ルートA」「ルートB」 |
| Node | Executor が処理する最小単位 | 台詞、BGM変更、選択肢 |

---

## 全体構成

```
GameManager（ゲーム全体）
  ├─ SaveManager（セーブ/ロード I/O）
  │
  └─ [シナリオ実行領域]
       ├─ GlobalState（共通フラグ・既読情報）
       ├─ ScenarioState（シナリオ固有変数）
       ├─ SceneRouter（シーン遷移判定）
       │
       └─ SceneController（シーン単位）
            ├─ Composer（UI配置）
            └─ Executor（進行制御）
                 └─ Features（表示・状態）
```

---

## 各コンポーネントの役割

### GameManager

ゲーム全体を管理する最上位のコンポーネント。

| 責務 | 説明 |
|------|------|
| モード管理 | title / loading / playing / paused |
| セーブ/ロード | SaveManager を呼び出し |
| ゲーム開始 | ニューゲーム / ロード再開 |

### SaveManager

セーブ/ロードのI/O専任。

| 責務 | 説明 |
|------|------|
| save(slotId) | 現在状態をストレージに保存 |
| load(slotId) | ストレージから状態を読み込み |
| getSlotList() | セーブスロット一覧（メタ情報）取得 |

保存先: 開発時は localStorage、本番は サーバーDB

### GlobalState

全シナリオで共通の状態。周回で蓄積される。

```typescript
type GlobalState = {
  readTexts: Set<string>           // 既読テキストID
  readScenes: Set<string>          // 既読シーンID
  unlockedEndings: string[]        // 到達済みエンディング
  unlockedCGs: string[]            // 解放済みCG
  majorChoices: Record<string, string>  // 主要分岐の選択結果
}
```

### ScenarioState

シナリオ固有の状態。セーブ/ロード対象。

```typescript
type ScenarioState = {
  // 進行位置
  currentChapterId: string
  currentSceneId: string
  currentFragmentId: string
  currentNodeIndex: number

  // シナリオ固有変数（自由形式）
  variables: Record<string, unknown>

  // 履歴・プレイ時間
  fragmentHistory: string[]
  playTime: number
}
```

### SceneRouter

シーン終了時に次シーンを決定する。

| 責務 | 説明 |
|------|------|
| evaluate() | 現在のフラグを評価し次シーンを決定 |
| 起動タイミング | シーン終了時のみ（リアクティブ監視なし） |

```typescript
type RouteRule = {
  condition: (global: GlobalState, scenario: ScenarioState) => boolean
  targetSceneId: string
  priority: number
}
```

### SceneController

個別シーンの初期化と調整を担当。

**処理の流れ**:
1. `scene.json` を読み込む
2. `type` から Archetype を取得（SceneArchetypeRegistry 経由）
3. Archetype の arrangement と scene.json の overrides をマージ
4. Feature の Store に初期データをセット
5. Composer を選択（カスタムがあればそれを、なければ AutoComposer）
6. Executor を起動

### Composer（SceneComposer）

Feature の Widget/Sprite を画面に配置する。

| 種類 | 説明 |
|------|------|
| AutoComposer | arrangement 情報から自動生成（シンプルなシーン用） |
| カスタム Composer | 手書きで配置を制御（複雑なシーン用） |

### Executor

シーン内の進行を制御。シーンタイプごとに異なる Executor を使用。

| シーンタイプ | Executor | 役割 |
|-------------|----------|------|
| chat, novel | DialogueExecutor | Fragment/Node を順番に処理 |
| exploration | ExplorationExecutor | マップ移動、アイテム取得 |
| battle | BattleExecutor | ターン制バトル処理 |

**処理の流れ**:
1. 現在の Fragment から Node を順次処理
2. ユーザー入力を待つ（台詞送り、選択肢）
3. Feature の Store を更新
4. 選択肢 → 対応 Fragment へ移動
5. Fragment 終了 → 次 Fragment or シーン終了
6. シーン終了時に SceneRouter を起動

---

## Feature（機能単位モジュール）

Feature は「状態 + UI + API」をバンドルしたモジュール。

```typescript
const Dialogue = {
  // PixiJS コンポーネント（Canvas内）
  Sprites: { ... },

  // Widget グループ（createLayer）
  Layers: { ... },

  // 単体 Widget（createWidget）
  Widgets: {
    MessageList: MessageListWidget,
  },

  // 状態アクセス
  hooks: {
    useDialogue(),         // 状態を読む（Widget/Sprite用）
    useDialogueActions(),  // 状態を更新する（Executor用）
  },
}
```

**重要**: Feature は受動的。自分では動かず、SceneController や Executor によって駆動される。

### 主要な Feature

| Feature | 役割 |
|---------|------|
| Background | 背景画像の表示・切り替え |
| Character | 立ち絵の表示・表情切り替え |
| Dialogue | メッセージ表示・話者名表示 |
| Audio | BGM/SE の再生 |

### Feature フォルダ構造

```
features/<Name>/
├── components/     # 生の React（内部用）
├── sprites/        # 生の PixiJS（内部用）
├── exports/        # ファクトリ適用済み（公開）
│   ├── *Widget.tsx
│   ├── *Sprite.tsx
│   ├── *Layer.tsx
│   └── index.ts    # バンドルエクスポート
├── hooks/
│   └── index.ts
└── stores/
    ├── index.ts
    ├── internalStore.ts
    └── useStore.ts
```

---

## Archetype（シーンの原型）

シーンタイプごとの標準構成を定義。

```typescript
const chatArchetype = {
  // このシーンで使う Feature
  features: ["Background", "Character", "Dialogue", "Audio"],

  // 使用する Executor
  executor: DialogueExecutor,

  // カスタム Composer（null なら自動生成）
  composer: null,

  // 配置設定（デフォルト値）
  arrangement: {
    sprites: [...],
    layers: [...],
  },
}
```

---

## scene.json の構造

```json
{
  "type": "chat",
  "chapterId": "chapter_1",

  "overrides": {
    "Dialogue.UI": { "bottom": "5%" }
  },

  "backgrounds": {
    "default": "church/default"
  },
  "initialBackground": "default",

  "characters": {
    "circus": { "position": "left" },
    "tatsumi": { "position": "right" }
  },

  "initialBgm": {
    "assetId": "存在しない街",
    "volume": 0.5
  },

  "fragments": {
    "intro": {
      "nodes": [
        { "type": "dialogue", "speaker": "circus", "text": "やあ" },
        { "type": "dialogue", "speaker": "tatsumi", "text": "こんにちは" },
        { "type": "choice", "options": [
          { "text": "選択肢1", "next": "route_a" },
          { "text": "選択肢2", "next": "route_b" }
        ]}
      ]
    },
    "route_a": {
      "nodes": [
        { "type": "dialogue", "speaker": "circus", "text": "そうか" }
      ],
      "next": "ending"
    },
    "route_b": {
      "nodes": [
        { "type": "dialogue", "speaker": "tatsumi", "text": "なるほど" }
      ],
      "next": "ending"
    },
    "ending": {
      "nodes": [
        { "type": "effect", "name": "fadeOut" }
      ],
      "sceneEnd": true
    }
  },

  "initialFragment": "intro"
}
```

| フィールド | 説明 |
|-----------|------|
| type | どの Archetype を使うか |
| chapterId | 所属チャプター |
| overrides | 配置のカスタマイズ |
| fragments | フラグメント定義 |
| initialFragment | 開始フラグメント |

---

## データフロー

### 通常の進行

```
scene.json
    ↓ 読み込み
SceneController
    ↓ type: "chat" → Archetype 取得
    ↓ arrangement + overrides をマージ
    ↓
Feature Stores に初期データをセット
    ↓
Composer → UI を描画
    ↓
Executor → Fragment/Node を順次処理
    ↓ ユーザー操作に応じて
Feature Stores を更新
    ↓ Zustand のリアクティビティ
Feature Components が再レンダリング
    ↓ Fragment 終了
次の Fragment へ or シーン終了
    ↓ シーン終了時
SceneRouter.evaluate() → 次シーン決定
```

### セーブ/ロード

```
【セーブ】
ユーザー操作
    ↓
SaveManager.save(slotId)
    ↓
現在位置（scene/fragment/node）+ 状態をシリアライズ
    ↓
ストレージに保存

【ロード】
ユーザー操作
    ↓
SaveManager.load(slotId)
    ↓
GameManager.startFromSave(saveData)
    ↓
SceneController.load(sceneId, fragmentId, nodeIndex)
    ↓
指定位置から Executor 再開
```

---

## ファクトリ

Feature のコンポーネントを生成するためのファクトリ関数。

| ファクトリ | 対象 | 効果 |
|-----------|------|------|
| createWidget | HTML コンポーネント | `position: absolute` + `zIndex` を注入 |
| createSprite | PixiJS コンポーネント | displayName を付与（パススルー） |
| createLayer | Widget グループ | `absolute` + `inset: 0` + `pointerEvents: none` + `zIndex` |
| createScene | Scene コンテナ | `absolute` + `inset: 0` |

---

## 命名規則

| サフィックス | 意味 |
|-------------|------|
| `*Sprite` | PixiJS コンポーネント（Canvas 内） |
| `*Layer` | Widget グループ（createLayer で生成） |
| `*Widget` | 単体の HTML コンポーネント（createWidget で生成） |
| サフィックスなし | 生の React コンポーネント（内部用） |

---

## 設計原則

### Executor はシンプルに

- Fragment 内の Node を順次処理
- 選択肢があれば対応 Fragment へ移動
- シーンレベルの判断は **しない**

### SceneRouter は受動的に

- シーン終了時にのみ起動
- フラグの監視やリアクティブな反応は **しない**
- 現在のフラグを参照して次シーンを決定するだけ

### Feature は受動的に

- 自分では動かない
- Executor からの Store 更新で反応する
- 状態を読む hooks と更新する hooks を分離

### シナリオ作者に表現力を

- 複雑な分岐も Fragment 構成で表現
- 即座にシーン遷移したいなら空の Fragment を作る
- エンジンに特殊ロジックを追加しない

---

## バリデーション（将来実装）

開発後半で Zod によるバリデーションを導入予定。

```typescript
const chatArchetype = {
  // ...
  schema: chatSceneSchema,
}

const chatSceneSchema = baseSceneSchema.extend({
  fragments: z.record(fragmentSchema),
  characters: z.record(characterSchema),
  backgrounds: z.record(z.string()),
})
```
