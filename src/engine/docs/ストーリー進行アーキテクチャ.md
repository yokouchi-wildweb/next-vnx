# ストーリー進行アーキテクチャ

## 用語定義

ストーリー進行の階層構造。上位から下位へ。

```
Chapter（チャプター）
  └─ Scene（シーン）
       └─ Fragment（フラグメント）
            └─ Node（ノード）
```

### Chapter（チャプター）

ストーリー上のまとまり。

- 例: 「第1章：出会い」「第2章：事件」
- 章タイトル、エンドロールなどの区切り
- セーブデータのサムネイル表示などで使用

### Scene（シーン）

画面レイアウトや機能が固定される単位。

- シーンタイプ（chat, battle, exploration など）を持つ
- 同一シーン内ではレイアウト・Feature構成が変わらない
- 背景、登場キャラクター、BGM などの初期設定を持つ
- 例: 「教室での会話シーン」「廊下の探索シーン」

### Fragment（フラグメント）

シーン内でのローカル遷移単位。

- 選択肢による分岐はフラグメント単位で行う
- 1つのシーン内に複数のフラグメントが存在可能
- セーブ位置の粒度として使用
- 例: 「導入部分」「選択肢後のルートA」「選択肢後のルートB」

### Node（ノード）

物語進行の最小単位。

- 1台詞、1コマンド、1演出
- Executor が順次処理する
- 例: 台詞表示、BGM変更、キャラ表情変更、選択肢表示

---

## アーキテクチャ構成

### 全体図

```
GameManager
  ├─ SaveManager          ← セーブ/ロード I/O
  │
  └─ [シナリオ実行領域]
       ├─ GlobalState     ← 共通フラグ、既読情報
       ├─ ScenarioState   ← シナリオ固有変数
       ├─ SceneRouter     ← シーン遷移判定
       └─ SceneController ← 現在シーンの実行
            ├─ Composer   ← UI配置
            └─ Executor   ← 進行制御
                 └─ Features ← 表示・状態
```

### コンポーネント責務

| コンポーネント | 責務 | トリガー |
|---------------|------|----------|
| GameManager | ゲーム全体管理、モード遷移（title↔playing） | ユーザー操作 |
| SaveManager | セーブ/ロードのI/O | GameManager から呼び出し |
| SceneRouter | シーン終了時に次シーンを決定 | シーン終了時に自動起動 |
| SceneController | シーン初期化、Feature配置、Executor起動 | SceneRouter からの遷移指示 |
| Executor | フラグメント/ノードの順次処理、選択肢分岐 | SceneController から起動 |

---

## 状態管理

### GlobalState（全シナリオ共通）

```typescript
type GlobalState = {
  // 既読管理
  readTexts: Set<string>       // 既読テキストID
  readScenes: Set<string>      // 既読シーンID

  // コレクション（周回で蓄積）
  unlockedEndings: string[]    // 到達済みエンディング
  unlockedCGs: string[]        // 解放済みCG

  // 主要な分岐結果（シナリオをまたぐ影響があるもの）
  majorChoices: Record<string, string>
}
```

### ScenarioState（シナリオ固有）

```typescript
type ScenarioState = {
  // 進行位置
  currentChapterId: string
  currentSceneId: string
  currentFragmentId: string
  currentNodeIndex: number

  // シナリオ固有変数（自由形式）
  variables: Record<string, unknown>

  // 履歴
  fragmentHistory: string[]    // バックログ用

  // プレイ時間
  playTime: number
}
```

---

## シーン遷移フロー

### 通常の進行

```
Executor
  │
  ├─ Node を順次処理
  │    ├─ 台詞表示 → Dialogue Store 更新
  │    ├─ BGM変更 → Audio Store 更新
  │    └─ ...
  │
  ├─ 選択肢 → ユーザー選択 → 対応 Fragment へ移動
  │
  └─ Fragment 終了 → 次 Fragment or シーン終了
       │
       ▼
  シーン終了
       │
       ▼
  SceneRouter.evaluate()
       │
       ├─ 現在のフラグを評価
       ├─ ルート定義と照合
       └─ 次シーンを決定
            │
            ▼
  SceneController.load(nextSceneId)
```

### シーン途中での強制遷移

エンジン側に特殊ロジックは不要。シナリオ作者が以下のように表現する：

```
選択肢
  ├─ 選択1 → Fragment A（通常の会話継続）
  ├─ 選択2 → Fragment B（通常の会話継続）
  └─ 選択3 → Fragment X（即終了用）
                │
                └─ 暗転エフェクトのみ
                └─ シーン終了
                     │
                     ▼
                SceneRouter で次シーン決定
```

**ポイント**: Executor は単純にフラグメント間を移動するだけ。即座にシーン移動したい場合は、内容のない（または暗転演出のみの）フラグメントを用意してシーンを終了させる。

---

## セーブデータ構造

### メタ情報（スロット一覧表示用）

```typescript
type SaveSlotMeta = {
  slotId: string
  savedAt: Date
  thumbnail: string           // スクリーンショット
  chapterName: string
  sceneName: string
  playTime: number
}
```

### 本体

```typescript
type SaveData = {
  // 位置情報
  chapterId: string
  sceneId: string
  fragmentId: string
  nodeIndex: number

  // 状態
  globalState: GlobalState
  scenarioState: ScenarioState

  // ビジュアル状態（復元用）
  visualState: {
    background: string
    characters: CharacterState[]
    bgm: string | null
  }
}
```

---

## セーブ/ロードフロー

### セーブ

```
ユーザー操作「セーブ」
      │
      ▼
SaveManager.save(slotId)
      │
      ├─ 現在位置を取得（sceneId, fragmentId, nodeIndex）
      ├─ GlobalState をシリアライズ
      ├─ ScenarioState をシリアライズ
      ├─ ビジュアル状態をスナップショット
      ├─ サムネイル生成
      └─ ストレージに保存
```

### ロード

```
ユーザー操作「ロード」
      │
      ▼
SaveManager.load(slotId)
      │
      ├─ ストレージから読み込み
      ├─ GlobalState を復元
      ├─ ScenarioState を復元
      │
      ▼
GameManager.startFromSave(saveData)
      │
      ├─ モード: "title" → "playing"
      ├─ SceneRouter に現在シーンを通知
      └─ SceneController.load(sceneId, fragmentId, nodeIndex)
           │
           ├─ シーン定義を読み込み
           ├─ Feature Store に初期値 + ビジュアル状態を復元
           ├─ Composer で描画
           └─ Executor を指定位置から開始
```

---

## SceneRouter の実装方針

### ルート定義

```typescript
type RouteRule = {
  // この条件が true のとき
  condition: (global: GlobalState, scenario: ScenarioState) => boolean

  // このシーンへ遷移
  targetSceneId: string

  // 複数マッチ時の優先度（高いほど優先）
  priority: number
}

type SceneRouteConfig = {
  // シーンID → そのシーン終了後のルート定義
  [sceneId: string]: RouteRule[]
}
```

### 評価ロジック

```typescript
function resolveNextScene(
  currentSceneId: string,
  global: GlobalState,
  scenario: ScenarioState,
  config: SceneRouteConfig
): string {
  const rules = config[currentSceneId] ?? []

  // 条件を満たすルールを優先度順に評価
  const matched = rules
    .filter(rule => rule.condition(global, scenario))
    .sort((a, b) => b.priority - a.priority)

  if (matched.length > 0) {
    return matched[0].targetSceneId
  }

  // マッチなし → デフォルト（次の連番シーン or エラー）
  return getDefaultNextScene(currentSceneId)
}
```

---

## 設計原則

### Executor はシンプルに

- フラグメント内のノードを順次処理
- 選択肢があれば対応フラグメントへ移動
- シーンレベルの判断は **しない**

### SceneRouter は受動的に

- シーン終了時にのみ起動
- フラグの監視やリアクティブな反応は **しない**
- 現在のフラグを参照して次シーンを決定するだけ

### シナリオ作者に表現力を

- 即座にシーン遷移したいなら、空のフラグメントを作る
- 複雑な分岐も、フラグメント構成で表現
- エンジンに特殊ロジックを追加しない
