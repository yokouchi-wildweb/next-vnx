# ユーザーのセッション管理と権限制御ガイド

JWT ベースのセッションを利用している本プロジェクトでは、サーバーコンポーネントから `authGuard` を呼び出すだけでルート保護とユーザー情報の取得を同時に行えます。さらに、`AuthSessionProvider` と `useAuthSession` フックを組み合わせることでクライアント側でも同じセッション情報を参照できます。

このドキュメントでは、ロール・ステータスによるルート制限の実装手順と、サーバー／クライアントの双方でセッション情報を扱う方法をまとめます。

---

## 1. 事前に押さえておく構成要素

| ファイル | 役割 |
| --- | --- |
| `src/features/auth/services/server/authorization.ts` | `authGuard` を提供し、Cookie から JWT を検証して `SessionUser` を返します。 |
| `src/features/auth/components/AuthSessionProvider.tsx` | サーバーでトークンを検証し、クライアントコンテキストへ初期ユーザー情報を渡します。 |
| `src/features/auth/components/AuthSessionClientProvider.tsx` | `fetchSession()` を使ってクライアントからセッション再検証を行います。 |
| `src/features/auth/hooks/useAuthSession.ts` | 認証コンテキストを取得するためのラッパーフック。`user` や `isAuthenticated` を参照できます。 |
| `src/constants/user.ts` | ロール・ステータスの定数をまとめています。`authGuard` でステータス制限を省略した場合は `USER_AVAILABLE_STATUSES`（`active` のみ）が自動で使われます。 |

---

## 2. `authGuard` の基本

`authGuard` はサーバーコンポーネント（`layout.tsx` や `page.tsx` など）でのみ使用でき、以下のオプションを受け取ります。

| オプション | 型 | 説明 |
| --- | --- | --- |
| `allowRoles` | `UserRoleType[]` | 許可するロールの配列。未指定の場合はロール制限なし。 |
| `allowStatuses` | `readonly UserStatus[]` | 許可するユーザーステータス。省略時は `USER_AVAILABLE_STATUSES`（`active` のみ）。 |
| `redirectTo` | `string` | 未ログイン・権限不足・ステータス不一致時にリダイレクトするパス。未指定の場合は `null` を返します。 |

```ts
// src/features/auth/services/server/authorization.ts
export async function authGuard(options: AuthGuardOptions = {}): Promise<SessionUser | null> {
  const cookieStore = await cookies();
  const token = parseSessionCookie(cookieStore);
  // ...中略...
  const allowedStatuses = options.allowStatuses ?? USER_AVAILABLE_STATUSES;
  if (!allowedStatuses.includes(sessionUser.status)) {
    if (options.redirectTo) {
      redirect(options.redirectTo);
    }
    return null;
  }
  return sessionUser;
}
```

> ℹ️ `redirectTo` を指定した場合は、検証に失敗した時点で `redirect()` が呼び出されるため戻り値は `null` になりません。

---

## 3. レイアウトでのルート制限

管理画面など配下のページを一括で守りたい場合は、該当ディレクトリの `layout.tsx` で `authGuard` を呼び出します。

```tsx
// src/app/admin/(protected)/layout.tsx
import { authGuard } from "@/features/auth/services/server/authorization";

export default async function AdminLayout({ children }: { children: React.ReactNode }) {
  await authGuard({ allowRoles: ["admin"], redirectTo: "/admin/login" });
  return <>{children}</>;
}
```

ユーザーステータスも厳密に絞りたい場合は `allowStatuses` を明示します。以下は「有効化済み（`active`）の一般ユーザーのみ」を許可する例です。

```tsx
await authGuard({
  allowRoles: ["user"],
  allowStatuses: ["active"],
  redirectTo: "/login",
});
```

---

## 4. サーバーコンポーネントでユーザー情報を利用する

`authGuard` は検証に成功すると `SessionUser` を返すため、そのままユーザー情報を使ったレンダリングが可能です。リダイレクト先を指定しない場合は、戻り値が `null` のときに未ログイン UI を描画できます。

```tsx
// src/app/(user)/(protected)/mypage/page.tsx
import { authGuard } from "@/features/auth/services/server/authorization";

export default async function MyPage() {
  const sessionUser = await authGuard({ allowRoles: ["admin", "user"] });

  if (!sessionUser) {
    return <p>ログインが必要です。</p>;
  }

  return (
    <div>
      <h1>ようこそ、{sessionUser.displayName} さん</h1>
      <p>現在のステータス: {sessionUser.status}</p>
    </div>
  );
}
```

`SessionUser` 型には `userId` / `role` / `status` / `providerType` / `providerUid` / `displayName` が含まれます。追加のユーザーデータが必要な場合は、この ID を使ってドメインサービスから詳細情報を取得してください。

---

## 5. クライアントからセッション情報を扱う

アプリ全体ではサーバーコンポーネントの `AuthSessionProvider` がラップされており、クライアント側では `useAuthSession` で同じ情報にアクセスできます。

```tsx
// 任意のクライアントコンポーネント
"use client";

import { useAuthSession } from "@/features/auth/hooks/useAuthSession";
import { err } from "@/lib/errors";

export function UserMenu() {
  const { user, isAuthenticated, refreshSession } = useAuthSession();

  if (!isAuthenticated) {
    return <p>ゲストとして閲覧中です</p>;
  }

  const handleRefresh = async () => {
    try {
      await refreshSession();
    } catch (error) {
      console.error(err(error, "セッションの更新に失敗しました"));
    }
  };

  return (
    <div>
      <p>{user.displayName} さんでログイン中</p>
      <button onClick={handleRefresh}>セッションを更新</button>
    </div>
  );
}
```

### セッションの再検証

`refreshSession()` は内部で `fetchSession()`（`/api/auth/session`）を呼び出し、トークンを再検証・再発行します。リクエストが失敗した場合は `user` が `null` に更新されるため、UI はそのまま未ログイン状態へ切り替わります。

---

## 6. よくある実装パターン

1. **管理者エリアの保護**：`/app/admin/(protected)/layout.tsx` で `allowRoles: ["admin"]` を指定し、未ログイン時は `/admin/login` へリダイレクト。
2. **ユーザー専用ページ**：`/app/(user)/(protected)/layout.tsx` で `allowRoles: ["admin", "user"]` を許可し、一般ユーザーと管理者の両方を通す。
3. **利用停止ユーザーの遮断**：`allowStatuses` に `["active"]` だけを渡して `inactive` や `suspended`、`banned` のユーザーを弾く。ユーザーが自分のステータスを切り替えるフォームを提供する場合は、更新後に `refreshSession()` を呼び出して最新状態を反映する。
4. **サーバーで詳細情報を読み込む**：`authGuard` の戻り値から `sessionUser.userId` を受け取り、サーバーサービス（例: `getUserProfile(userId)`）経由で詳細データを取得してページに渡す。

---

## 7. トラブルシューティング

- `authGuard` が常に `null` を返す場合は、セッションクッキー `__session` が存在するかと、`verifyUserToken` に必要な環境変数（`AUTH_JWT_SECRET`）が設定されているかを確認してください。
- クライアントで `refreshSession()` が失敗したときはネットワークエラーや API のレスポンスを確認し、`err(error, "...")` を通じてユーザーへ適切な文言を提示してください。
- ステータス制限を追加したのに意図通り動作しない場合は、`USER_AVAILABLE_STATUSES` が既定値として利用されていないか確認し、`allowStatuses` を明示的に指定しましょう。

---

以上でサーバー・クライアントの両面からセッション管理と権限制御を実装するための基本的なフローが揃います。`authGuard` と `useAuthSession` を適切に組み合わせ、利用者のロールやステータスに応じた安全な画面遷移と UI 表示を実現してください。
