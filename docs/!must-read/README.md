# 開発者向け必読ドキュメント

このディレクトリには、開発を開始する前に必ず理解しておくべきドキュメントが格納されています。

---

## ✅ 動作要件

- Node.js 20.9 以上（Next.js 16 の公式要件に準拠）
- Next.js 16 系（本テンプレートで検証済みのメジャーバージョン）

すぐに環境構築からデプロイまで体験したい場合は、下記ハンズオンを参照してください。

- [クイックスタート_環境構築からデプロイまでの方法.md](../how-to/initial-setup/クイックスタート_環境構築からデプロイまでの方法.md)

---

## 📁 プロジェクトのディレクトリ構成

詳細なディレクトリ構造は以下のドキュメントを参照してください。

➡️ [ディレクトリ構造の全体図.md](../concepts/ディレクトリ構造の全体図.md)

---

## 🏗️ アプリ全体アーキテクチャ概要

```
ページ層 → UIコンポーネント層 → フック層 → クライアントサービス層 → APIルート層 → サーバーサービス層 → データベース
```

※ ドメインエンティティ層は上記フローに常時連結するのではなく、サーバーサービス層やフォーム処理など各プロセスから参照される独立した基盤レイヤーとして存在します。

| 層 | 主な責務 | 禁止事項の例 |
| --- | --- | --- |
| ページ層 (`app/**/page.tsx`) | SSR/SSG、リダイレクト、初期データ整形。サーバーサービスを直接呼び出しても良い。 | クライアントフックの直接利用、DB の操作（サーバーサービスを利用すべき）。 |
| UIコンポーネント層 (`features/<domain>/components`) | 表示とイベント定義。例えば `features/<domain>/components/XxxSection/index.tsx` をエントリーポイントに据え、`XxxSection` フォルダ直下へセクション構造と子部品をまとめる。 | axios や DB への直接アクセス、ビジネスロジックの混在。 |
| フック層 (`features/<domain>/hooks`) | クライアントでの状態管理とクライアントサービス呼び出し。 | HTTP クライアントの直接利用、`toast()` など UI 通知の埋め込み、`HttpError` の throw。 |
| クライアントサービス層 (`features/<domain>/services/client`) | axios で通信の一元化、`normalizeHttpError` によるエラー正規化、その他 API の利用。 | React 状態の保持、UI ロジック、`fetch` の利用（通信は全て axios を使用）。 |
| APIルート層 (`app/api/**`) | HTTP I/F の整形とサーバーサービス呼び出し。 | Drizzle/Firestore の直接操作、DomainError の新規 throw。 |
| サーバーサービス層 (`features/<domain>/services/server`) | ビジネスルールと永続化アクセス。`DomainError` を軸に例外を管理。 | クライアント向け HTTP クライアント実装の持ち込み、UI に依存する処理。 |
| ドメインエンティティ層 (`features/<domain>/entities`) | Zod スキーマ、`z.infer` 型、Drizzle テーブル定義などの正規形を提供する独立レイヤー。 | 特定のフォーム固有のスキーマなど再利用性がないスキーマの追加。 |
| データベース | Neon(PostgreSQL) や Firestore など。 | アプリ層からの直接アクセス。 |

**クロスカットポリシー**

- クライアント通信は axios を必須とし、`features/<domain>/services/client` 以外で HTTP クライアントを生成しない。
- DB へのアクセスは必ずサーバーサービス層を経由し、API ルートから直接 Drizzle/Firestore を操作しない。
- エンティティ層では共通スキーマと型のみ保持し、個別性の高い定義はコンポーネント配下へ隔離することで肥大化を防ぐ。

詳細な役割・ワークフローは [アプリ構築における構成層.md](./アプリ構築における構成層.md) を参照してください。

---

## 🧩 コンポーネント設計ガイドライン

- ページ → セクションコンテナ → ユニットアイテム → インタラクション部品の 4 階層で責務を分離し、`page.tsx` は `<Main>(mainタグのラッパー)` と最小限のタグに限定する。
- セクションコンテナは必ず `PascalCase/index.tsx` で定義し、呼び出し元は `index.tsx` のみを参照する。複雑化したら内部へ部品を切り分ける。
- フックは状態管理を握る上位階層（多くはセクションコンテナ）から呼び出し、下位要素へはイベントハンドラを Props で渡す。独立して処理が完結する再利用部品のみ例外的にフック呼び出しを許容する。
- UI 通知（トーストなど）はコンポーネント側で制御し、フック内へ埋め込まない。`"use client"` 宣言は必要最小限とし、基本はサーバーコンポーネントで構築する。
- 文書構成要素やボタンなどは `src/components/TextBlocks`・`src/components/Form` にある汎用部品を優先利用し、生の HTML 要素を直接使用しない。

判断基準と実装パターンの詳細は [コンポーネントの設計と切り分け方.md](./コンポーネントの設計と切り分け方.md) を必ず参照してください。

---

## 🚧 エラーハンドリング戦略

- サーバーサービス層はビジネスルール違反時に `DomainError` を throw し、`status` とユーザー向け `message` を必ず整備する。想定外の例外は上位へ伝播させる。
- API ルート層は `DomainError` を `{ status, message }` へ正規化し、それ以外の例外も JSON へ変換したうえでレスポンスを返す。ロギング・監視もこの層で行う。
- クライアントサービス層は axios 例外を `normalizeHttpError` で `HttpError` に統一し、生の例外を上位に渡さない。HTTP 以外のエラーも `createHttpError` で正規化する。
- フック層は `HttpError` を前提に UI へ渡し、追加の正規化処理を持ち込まない。クライアントサービスを経由しない失敗（外部 SDK、ブラウザ API など）は `createHttpError` で新規に生成し、UI が一貫した型で扱えるようにする。
- UI 層では `err(error, fallback)` を用いて文言を決定し、トーストやフォームエラーへ反映する。
- コンポーネント・フック・クライアントサービス間で責務が曖昧になりやすいため、各層の役割を徹底する。

詳しい内容は [エラーハンドリング方針.md](./エラーハンドリング方針.md) を参照する。

---

## ⚙️ ドメインエンティティと型管理方針

**基本指針**

- `entities/schema.ts` はサーバー処理で利用する汎用スキーマのみを定義し、`XxxBaseSchema` / `XxxCreateSchema` / `XxxUpdateSchema` を基本形とする。フォーム固有の仕様を持ち込まない。
- `entities/form.ts` では `schema.ts` の `z.infer` 型だけを公開し、追加スキーマや合成処理は禁止。必要な差分は型の交差で拡張する。
- フォーム固有の入力要件はコンポーネント配下の `formEntities.ts` に閉じ込め、共通エンティティを肥大化させない。
- 新規ドメイン追加時はスキーマ定義 → `z.infer` 型公開 → フォーム専用スキーマ分離の順に確認し、チェックリストを運用する。

**複雑なドメインへ拡張する場合の指針**

- フォームや API が増えて共通スキーマだけでは足りなくなったら、再利用できる単位で `schema.ts` の定義を分割し、必要に応じて `entities/` 配下へ小さなサブフォルダを作って整理します。
- 共通化できない細かな入力差分は、迷わずコンポーネント配下の `formEntities.ts` など UI 側へ隔離し、`entities/` には共有したい最小限の定義だけを残します。
- 新しく追加した型は `entities/index.ts` から再エクスポートできているか、既存コードが同じ入口で参照できるかを確認し、影響範囲のメモを残しておくと保守しやすくなります。

詳細なチェックリストと実装例は [ドメイン内のエンティティ管理方針.md](./ドメイン内のエンティティ管理方針.md) を参照してください。

---

## 🎨 全体的なスタイル運用ガイド

> 🚫 クラス名ベースのスタイリングは最終手段
> ⚠️ 生のHTMLではなく汎用コンポーネントを使用

- **クラス名を直接付与してスタイリングする行為は極力避けます。** 既存の汎用コンポーネントやそのバリアントで表現できないかを必ず確認してください。
- 基本的には `src/components` 配下に存在するコンポーネントとそのバリアントを利用してスタイルを構築します。Shadcn ベースのラッパーや `cva` で定義されたバリアントを優先的に採用します。
- `src/components/README.md` を参照しながら、用途に合ったラッパーを選択してください。
- 特に下記フォルダは使用頻度が高い部品が用意されているので要確認
  - `Layout`（レイアウト用のdivなど）
  - `TextBlocks`（p,sectionなど文章構成用）
  - `Form`（ボタンなどフォーム部品）
- 既存のコンポーネントで対応できない場合は、新たなラッパーコンポーネントやバリアントを追加して再利用性を高めます。その際はドキュメントや props の整理も合わせて実施します。

| 従来の要素・使用意図           | 使用すべきコンポーネント                                                                   | 説明                                                                           |
|----------------------|--------------------------------------------------------------------------------|------------------------------------------------------------------------------|
| 余白調整などレイアウト用の div    | `src/components/Layout` の要素<br />`src/components/TextBlocks/Para.tsx`          | デフォルトで適度なマージンを保持している。`Block`, `Flex` は子要素の余白調整も可能。                           |
| エラー、補足などテキストの見た目を変える | `src/components/TextBlocks/Para.tsx`<br />`src/components/TextBlocks/Span.tsx` | バリアントでテキスト色やサイズを変更可能。                                                        |
| 従来の button 要素の使用箇所   | `src/components/Form/Button.tsx`                                               | 多様なバリアントが用意されている。                                                            |
| セマンティックな文章構造を作成したい   | `src/components/TextBlocks` の要素                                                | `Section` は adide, articleなど各種セクショニング要素として使用可能。 hx要素に相当する `SecTItle` などを活用する |

詳細は [Tailwindと汎用部品を利用した共通スタイル設計.md](./Tailwindと汎用部品を利用した共通スタイル設計.md) を参照してください。

---

## ✨ ドメイン追加方法について

- **スクリプトによる自動生成**：`npm run dc:init` で `domain.json` の初期雛形を作成し、設定を記述したうえで `npm run dc:generate -- <Domain>`（もしくは `node scripts/domain-config/index.mjs --generate <Domain>`）を実行すると、`features/_template` をもとにエンティティ・サービス・フック・レジストリ更新などの雛形を生成できます。生成後は差分を確認し、不要な項目を整理してください。
- **汎用 CRUD の活用**：`src/lib/crud` の共通処理で完結する場合（単一テーブル、共通の検索・並び替え設定で足りるケース、外部サービス連携なしなど）は、生成されたベースサービスを登録するだけで API・SWR フックまで揃います。検索機能は Neon/PostgreSQL と Firestore で利用できるオプションが一部異なるため、必要な条件がサポートされるか事前に確認してください。
- **個別実装が必要なケース**：
  - 複数テーブルの JOIN やドキュメント間集計など、単一テーブル CRUD に収まらない処理が必要なとき。
  - 外部ストレージや他サービスとの双方向同期が発生し、トランザクション制御やリトライが求められるとき。
  - ドメイン固有の認可・監査ログ・バッチ連携など、リクエスト単位で複雑なビジネスルールを挟みたいとき。
  - Firestore と Neon で提供される検索機能の差分を吸収する必要があり、共通 CRUD だけでは表現しきれないとき。

これらの場合は `services/server/wrappers/` へ処理を追加し、共通サービスの前後に独自ロジックを組み込みます。必要であれば Firestore 用と Neon 用にサービスを分岐させて対応してください。
判断基準や作業手順の詳細は [汎用CRUDの仕様と拡張方法について.md](./汎用CRUDの仕様と拡張方法について.md) を参照してください。

> ⚖️ 関連: [DB種別の違いによる機能の差異.md](../core-specs/DB種別の違いによる機能の差異.md)

---

## 🗂️ プロジェクトファイルの命名規則

命名の揺れは層構造の責務分離を崩す原因になるため、以下のドキュメントを参照してファイル・ディレクトリを作成してください。

➡️ [プロジェクトファイルの命名規則.md](../concepts/プロジェクトファイルの命名規則.md)

---

## 📘 追加ドキュメントについて

`docs/` フォルダは下記のサブフォルダで構成されています。

- `docs/!must-read/`：層構成・コンポーネント設計・エラーハンドリング・エンティティ管理・スタイル設計など、開発開始前に必ず読むべきドキュメントを格納しています。
- `docs/concepts/`：アーキテクチャ方針・ドメイン運用・ネーミング規則など、設計判断の背景やルールを整理した資料。
- `docs/how-to/`：環境構築やフォーム設計といった手順書。
- `docs/reference/`：使用ライブラリや Next.js バージョンアップ情報などのリファレンス集。
- `docs/troubleshooting/`：発生しがちな事象と対処法のナレッジベース。

### ドキュメント配置ポリシー

- プロジェクト全体に共通する運用ルールや開発手順は、これまで通り `docs/` 配下に集約します。
- ドメイン／機能固有の仕様・補足は、必ず該当フォルダ直下（例: `src/features/foo/README.md` や `src/app/(user)/foo/README.md`）に README を置いて管理します。
- `docs/` と各フォルダの README が同一トピックを扱う場合、`docs/` 側では要点のみ簡潔に記載し、詳細説明はコロケーションされた README に集約して相互リンクします。
- `docs/` から各フォルダの README へリンクを張り、参照起点を一本化することで迷子を防ぎます。新規 README を追加したら、このセクションも更新して導線を整備してください。

### 推奨ドキュメント

- [使用ライブラリ一覧.md](../reference/使用ライブラリ一覧.md)：主要ライブラリの役割・採用理由・利用時の注意点をカテゴリ別に整理したリファレンス。
- [ユーザーセッションの管理方針と実装.md](../concepts/ユーザーセッションの管理方針と実装.md)：JWT ベースで管理者・一般ユーザーを統合管理するセッションアーキテクチャを詳細に解説。
- [ユーザー登録と認証の方針.md](../concepts/ユーザー登録と認証の方針.md)：プロバイダーごとのアカウント運用やデータモデル、登録フローを網羅した設計指針。
- [NextJS_バージョンごとの重要な変更点](../reference/NextJS_バージョンごとの重要な変更点)：Next.js 15 系で必ず把握すべき非同期 `params` 対応や Firebase Hosting との連携時の注意点をまとめたアップデートガイド。

これらに加え、`docs/!must-read/` 配下のドキュメントは開発前に必読とし、疑問点が生じた場合は必ず原典を参照してください。
