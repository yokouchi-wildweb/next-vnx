# 🧱 アプリ内の構成層まとめ

このドキュメントは、Next.js（App Router）ベースのアプリケーションにおける層構成と責務の役割を明確化したものです。  
アプリ全体の保守性・再利用性・責務分離を高めるため、各層は必ず定義された責務に従って実装してください。

---

## 🗂️ ドメインフォルダの基本構造

1つのドメインは下記のような階層で構成されています。

```
src/features/<domain>/
  components/    … UIコンポーネント（例: AdminXxxList）
  hooks/         … フロントエンド用のReactフック（例: useXxx）
  services/
    client/      … API呼び出し（axios）をまとめる層
    server/      … DBや外部サービスにアクセスするサーバー層
  entities/      … サーバー用スキーマと派生型（UI固有の定義は含めない）
  domain.json    … 管理画面やCRUD設定のメタ情報（必要なドメインのみ）
```

---


## 🔁 データフロー（ページからDBまで）

```
1. ページ層 `src/app/**/page.tsx`（SSR/SSG）
  ↓
2. UIコンポーネント層 `src/features/<domain>/components/**`
  ↓
3. フック層 `src/features/<domain>/hooks/useXxx.ts`
  ↓
4. クライアント・サービス層 `src/features/<domain>/services/client/**`
  ↓
5. APIルート層 `src/app/api/**`
  ↓
6. サーバー・サービス層 `src/features/<domain>/services/server/**`
  ↓
7. ドメインエンティティ/DBアクセス `src/features/<domain>/entities/**`
  ↓
8. データベース（Drizzle, Firestore など）
```

データの出入りは必ずこの順番で流れます。
例えば、サンプルドメインの詳細ページでは `page.tsx` が
サーバーサービスを使って初期データを取得しUIコンポーネントに渡します。
クライアント側での更新は 
`hooks` → `client services` → `API` → `server services` → `entities` → `DB` の順で処理されます。

> ⚠️ **クライアント層での通信ポリシー**
>
> クライアント環境で HTTP 通信を行う場合は **必ず axios を使用し、
> `fetch` の利用は禁止**です。
> クライアントサービス層（`services/client/`）で通信処理を集約し、
> UI やフックからは直接 HTTP クライアントを呼び出さないようにしてください。

---

## 🧩 各層の定義と責務

### 1. ページ層（`page.tsx`）

- **実行環境**：サーバー
- **特徴**：
  - SSR/SSGでの初期データ取得やリダイレクト制御を担当
  - クッキー・セッション・認証情報などサーバーコンテキストを扱える
  - `server/services` を直接呼んでもよい
- **責務**：
  - ページ単位のデータフェッチとレイアウト構築
  - UIコンポーネントへ渡すPropsの整形
- **禁止**：
  - Reactのクライアントフック（`useState`, `useEffect` など）の使用
  - APIルートや`fetch`を直接たたくこと（サーバーサービス経由で取得する）

---

### 2. UIコンポーネント層

- **実行環境**：原則サーバー / クライアント（必要に応じて）
- **特徴**：
  - `use client` を書かなければサーバーコンポーネントとして機能する
  - 表示・入力・イベント発火を担う純粋なUI
- **責務**：
  - UIの描画とユーザー操作からフック層を呼び出すためのイベントハンドラ設定
  - 処理終了後の通知・UI操作・画面遷移などUIに密着した処理
- **禁止**：
  - HTTP クライアント（axios など）による通信処理
  - DBやAPIの知識（エンドポイントのパス、SQLの構造など）を持ち込むこと

---

### 3. フック層（`useXxx.ts`）

- **実行環境**：クライアント
- **特徴**：
  - Reactの状態管理を用いて通信状況（`isLoading`, `error` など）をUIに伝える
  - `services/client` の関数を呼び出し、副作用を発生させる
  - クライアント・サービス層の関数をラップして使用（SWR形式でのデータ取得など）
- **責務**：
  - UIとクライアントサービスの橋渡し
- **禁止**：
  - HTTP クライアント（axios など）によるデータ通信処理
  - トースター表示、モーダル展開などUI的な通知
  - HttpErrorをスローする

---

### 4. クライアント・サービス層

- **実行環境**：クライアント
- **特徴**：
  - axios を用いて HTTP 通信を一元管理
  - エンドポイント・HTTPメソッド・Zodによるレスポンスバリデーションを定義します
- **責務**：
  - 通信処理の抽象化と再利用可能なAPIクライアントの提供
  - 認証ヘッダーやクエリパラメータの組み立てなど、HTTP層の細かいルールを吸収
  - HttpErrorをスローする
- **禁止**：
  - Reactの状態管理やUI操作
  - DBアクセスやビジネスロジックの実装

---

### 5. APIルート層（`/api/xxx`）

- **実行環境**：サーバー
- **特徴**：
  - クライアントからのHTTPリクエストを受け取り最低限のバリデーションのみ実施
  - 詳細な値の検証などはAPIではなくサーバーサービスに委ねる
  - サーバーサービスを呼び出して実際の処理を行う
- **責務**：
  - 外部インターフェースとしてのREST APIを定義
  - リクエスト/レスポンス形式の保証、エラーハンドリング
- **禁止**：
  - 具体的なビジネスロジックの記載
  - DBやDrizzleを直接操作すること（必ずサーバーサービス層へ委譲）
  - UI状態やReactロジックの利用
  - DomainErrorを新たにスローする

> ⚠️ **必須: routeFactory の使用**
>
> すべてのAPIルートは `@/lib/routeFactory` のファクトリー関数を経由して作成してください。
> 直接ハンドラをエクスポートすることは禁止です。
>
> ```ts
> // ✅ 正しい例
> import { createApiRoute } from "@/lib/routeFactory";
> export const GET = createApiRoute(
>   { operation: "GET /api/example", operationType: "read" },
>   async (req, { session }) => { ... }
> );
>
> // ❌ 禁止例
> export const GET = async (req: NextRequest) => { ... };
> ```
>
> ファクトリーは認証情報の取得、エラーハンドリング、デモモード制御などの共通処理を一元管理します。
> 詳細は `src/lib/routeFactory/README.md` を参照してください。

---

#### 6. サーバー・サービス層 `services/server/`

- **実行環境**：サーバー
- **特徴**：
  - Drizzleやその他のデータアクセスライブラリを利用して永続化を行う
  - 共通処理を `base.ts` や `wrappers/` に切り出し、ドメインごとのロジックを組み立てる
- **責務**：
  - ビジネスルールに沿ったデータ取得・更新・削除
  - トランザクション管理や外部サービス（Firebase Storageなど）との連携
  - DomainErrorをスローする
- **禁止**：
  - HTTP クライアント（fetch や axios）によるクライアント向け通信。
  - ReactやNext.jsのUIロジック。

---

### 7. ドメインエンティティ/DBアクセス層（`entities/`）

- **実行環境**：（型定義自体はどこでも利用可能）
- **特徴**：
  - Drizzleテーブル定義（`drizzle.ts`）
  - サーバー向け Zod スキーマ（`schema.ts`：`XxxBaseSchema`／`XxxCreateSchema`／`XxxUpdateSchema`）の管理
  - スキーマを `z.infer` した型 (`form.ts`) やドメインモデル (`model.ts`) を切り分け、型の重複を防ぐ
- **責務**：
  - ドメインデータの構造・バリデーション・DBマッピングの定義
  - 他層から利用される型を提供する
- **禁止**：
  - 直接通信を行う処理の記述
  - UIに依存した型（`useState` の戻り値など）の定義
  - フォーム固有のスキーマ定義（フォーム配下の `formEntities.ts` で管理する）

---

### 8. データベース層

- **実行環境**：サーバー（PostgreSQL, Firestoreなど）
- **特徴**：
  - DrizzleやFirebase SDKを通じてアクセスする
- **責務**：
  - 永続化されたデータの保存・検索・更新
- **禁止**：
  - アプリケーションコードから直接生SQLやSDKを呼ぶこと（必ずサーバーサービス層経由）

---

## 💬 よくある判断ポイントまとめ

| ケース | OK/NG | 理由 |
| --- | --- | --- |
| `page.tsx` から `server/services` を呼ぶ | ✅ OK | 同じサーバー環境内で完結し、SSRでのデータ準備に最適だから。 |
| フック層から `server/services` を呼ぶ | ❌ NG | クライアント環境でサーバー専用コードを実行できずビルドエラーになる。 |
| UIコンポーネントで `fetch` を書く | ❌ NG | 通信の責務はクライアントサービス層に集約し再利用性を確保するため。 |
| API内で Drizzle を直接使う | ❌ NG | データアクセスロジックはサーバーサービス層に閉じ込め、共通化・テストしやすくするため。 |
| `hooks` から `cardClient` を呼ぶ | ✅ OK | クライアントサービスを介して通信する正しい経路であり、`useCard.ts` などがこの形を取っている。 |
| `entities` にフォームのローカル状態を持たせる | ❌ NG | 型定義層がUI依存になると再利用性が下がり、他層から参照しづらくなる。 |
| 新しいAPIを追加する際に `services/server` を通さず `route.ts` にロジックを書く | ❌ NG | サーバーサービスに集約しないとドメインごとの共通処理（権限チェック等）が散在する。 |


---

## ✅ 層構成の開発者向け認識

アプリ開発者が直接触れる主な場所：

- `src/app/**/page.tsx`：SSRとしてサーバーサービスからデータを取得。
- `src/features/<domain>/components/**`：UI表示とイベント発火。
- `src/features/<domain>/hooks/**`：クライアントから通信を行うフック。
- `src/features/<domain>/services/client/**`：HTTP通信の窓口。
- `src/features/<domain>/services/server/**`：DBや外部サービスとのやり取り。
- `src/features/<domain>/entities/**`：サーバー用スキーマと `z.infer` 型、Drizzle 定義などの共有場所。

**DBアクセス（DrizzleやFirestore）は `services/server` 経由でのみ行われる内部実装として扱う。**


---

## 🧠 設計の基本方針

- axios による通信は必ずクライアントサービス層に集約し、フックはそれを呼び出すだけにする。
- DB操作（Drizzle/Firestore）は必ずサーバーサービス層に集約し、APIルートから直接触らない。
- エンティティ層ではサーバー処理で利用するスキーマと派生型を整理し、UI固有の定義は各フォームへ切り離す。
- - APIルートは最小責務：**検証 → 呼び出し → レスポンス**
