# ウォレット機能の設計と運用ガイド

複数種類のアプリ内リソース（通常ポイント、ボーナスポイント、コイン、ルビーなど）を共通の仕組みで管理するためのウォレット設計方針をまとめます。  
`wallet` / `wallet_history` の 2 テーブルを基盤とし、任意のリソースを `type` カラムで区別します。

---

## 1. ウォレット構造

| テーブル | 主なフィールド | 説明 |
| --- | --- | --- |
| **wallet** | `user_id` | ユーザー ID |
|  | `type` | `regular_point` / `bonus_point` / `temporary_point` / `coin` / `ruby` など、リソース名を識別する列挙。`user_id` と合わせてユニーク制約を張る |
|  | `balance` | 現在の残高 |
|  | `locked_balance` | 進行中リクエストで予約済みの残高。`balance - locked_balance` が即時に使える金額となる |
|  | `updated_at` | 最終更新 |

| テーブル | 主なフィールド | 説明 |
| --- | --- | --- |
| **wallet_history** | `id` | 履歴 ID |
|  | `user_id` | ユーザー |
|  | `type` | 更新対象のウォレット種別 |
|  | `change_method` | `INCREMENT` / `DECREMENT` / `SET` |
|  | `points_delta` | `INCREMENT/DECREMENT` では増減量、`SET` の場合は上書き後の絶対値 |
|  | `balance_before` / `balance_after` | 変動前後の残高 |
|  | `source_type` | `user_action` / `admin_action` / `system` などの区別 |
|  | `request_batch_id` | 連続処理の親 ID（単発なら `null`） |
|  | `reason` | 変化理由の短い説明 |
|  | `meta` | JSONB でリソース固有の付随情報を保持（例: `machineId`, `transactionId`） |
|  | `created_at` | 記録日時 |

---

## 2. ロックと残高の扱い

1. **残高チェック**: 利用可能残高 `available = balance - locked_balance` を算出し、操作に必要な額を満たすか判定する。
2. **予約 (lock)**: リクエスト単位で必要額 `reserve` を求め、`locked_balance += reserve` を行ってから処理を開始する。
3. **確定消費 (consume)**: バッチ処理中は各ステップで `locked_balance -= unit` と同額の `balance -= unit` をセットで行い、予約分を確定させる。
4. **失敗時の返却**: エラーで処理を中断する場合は、残っている予約分だけ `locked_balance` を戻す。`balance` は減らさないのでトランザクション整合性を保てる。

このルールにより、並列リクエストでも二重消費を防ぎ、予約／確定の状態遷移をわかりやすく管理できる。

---

## 3. リクエスト単位の管理

- 10 連 / 100 連など複数回実行する操作は、サーバーが `request_batch_id` を生成し、`wallet_history` と関連ドメイン（例: `gacha_play_history`）で同じ ID を共有する。
- UI は `request_batch_id` ごとにグループ化して表示できるため、100 連を 1 つのまとまりとして解釈できる。
- バッチジョブ（例: 有効期限切れのポイント返還）も `request_batch_id` を使えば追跡・再実行が容易になる。

---

## 4. メタ情報 (`meta`) の活用

- JSONB 形式で任意のキーを保存できる。ウォレットでは最低限として **ポイントを消費した対象の商品 ID**（`meta.productId`）や **紐づくガチャ / 注文 ID**（`meta.gachaId`, `meta.orderId` など）を格納し、履歴から直接関連エンティティをたどれるようにする。
- 管理者操作では `meta.adminId` に管理者 ID を保持し、`meta.operatorScreen` や `meta.notes` などで UI 由来の情報・問い合わせ番号を記録する（`operator_id` カラムは持たず、JSONB に一元化する）。
- その他任意のログ（例: `{ "machineId": "xxx", "machineName": "レアガチャ", "playCount": 10 }`）も必要に応じ追加できる。
- **インデックス運用**: 現状は小規模運用のためインデックスを保持せず、実際に検索・集計したいキーが固まった段階で `entities/drizzle.ts` に `CREATE INDEX` を定義し、`db:generate` → `db:push`（`drizzle-kit`）で適用する。`meta ->> 'productId'` など頻出キーには GIN インデックスを貼ることで高速化できる。

---

## 5. 多通貨対応の方針

- 新しいリソースは `type` に値を追加するだけで登録できる。例: `coin`, `ruby`, `event_token`。
- `wallet` を共通化することで CRUD・残高チェック・履歴記録の処理フローを全リソースで共有でき、テーブル増殖を避けられる。
- 期限付きリソース（`temporary_point` など）は別テーブルで期限情報を管理しつつ、還元や失効時に `wallet` / `wallet_history` を更新する。

---

## 6. 実装時のチェックリスト

1. 操作前に `available >= reserve` を確認してから `locked_balance` を更新しているか。
2. 失敗時に残りのロックを必ず解放しているか。
3. `wallet_history` に `type`, `request_batch_id`, `reason`, `meta.productId` / `meta.orderId` / `meta.adminId` など必要情報を忘れず記録しているか。
4. リクエスト単位で `request_batch_id` を共有し、表示や監査で活用できる状態か。
5. 新しいリソース種別を追加した際、`type` の enum を更新し、必要な初期残高を投入しているか。

ウォレットを共通インフラとして整備することで、ポイント以外のリソースを柔軟に追加しつつ、監査・履歴・残高管理を統一できます。

---

## 7. 既存コアドメインとの連携

- **ユーザー / 認証ドメインとの接続**: `wallet` / `wallet_history` の `user_id` は `core/user` が管理する ID を参照し、ログイン済みユーザーの残高取得や操作は `core/auth` による認証結果を前提に行う。管理者操作も `core/auth` の管理者 ID を `meta.adminId` として記録する。

---

## 8. 連携時に参照すべきファイルとエントリ

| 利用シーン | ファイル / 関数 | ポイント |
| --- | --- | --- |
| サーバー側からポイントを操作したい | `src/features/core/wallet/services/server/walletService.ts` の `adjustBalance` / `reserveBalance` / `releaseReservation` / `consumeReservedBalance` | いずれも `tx?: TransactionClient` を取れるハイブリッド設計。外側で `db.transaction` を開始した場合は `tx` を渡し、単体実行の場合は未指定で OK。 |
| ロック→確定フローを組みたい（ガチャ・バッチ・注文確定など） | 同上 `reserveBalance` → `consumeReservedBalance`（必要に応じて `releaseReservation`） | ロック残高と実残高を分離して制御。`meta` / `requestBatchId` を渡せば履歴トレースも容易。 |
| 管理画面から調整したい | `src/app/api/admin/wallet/[userId]/adjust/route.ts`（API） + `src/features/core/wallet/components/AdminWalletAdjustModal`（UI） | 管理者の `meta.adminId` を自動付与。`useAdjustWallet` フック & `walletClient.adjustBalance` で呼び出し。 |
| クライアントから残高/履歴を参照したい | `src/features/core/wallet/hooks/useWallet`, `useWalletList`, `useWalletBalances` / `src/features/core/walletHistory/hooks/*` | SWR ベースの取得フック。`useWalletBalances` はユーザーID単位で通常ポイント/期間限定ポイントをまとめて返す。 |
| スキーマやマイグレーションを追加・更新したい | `src/features/core/wallet/entities/*`, `src/features/core/walletHistory/entities/*`, `src/registry/schemaRegistry.ts` | Drizzle 定義を更新後、`npm run db:generate` → `npm run db:push` で Neon に反映。 |
| メタ情報の型やフォームの参考資料 | `src/features/core/walletHistory/types/meta.ts`, `src/features/core/wallet/components/AdminWalletAdjustModal/formEntities.ts` | `meta` の基本キー（productId / orderId / gachaId / adminId / notes）とフォームでの入力例を参照。 |
| ドメイン自動生成を再実行したい | `src/features/core/wallet/domain.json`, `src/features/core/walletHistory/domain.json` + `npm run dc:generate -- wallet` | domain-config の修正で CRUD 雛形を再生成可能。`getDomainConfig` に登録済みなので `serviceRegistry`/`schemaRegistry` との整合も取りやすい。 |

> サービス層は「ベース CRUD (`drizzleBase.ts`)」「ドメインロジック本体 (`walletService.ts`)」「責務別ラッパー (`wrappers/*.ts`)」に分割し、用途に応じた関数をピンポイントで呼び出す。まず `walletService` を入口として捉え、必要なら `tx` を渡して既存トランザクションへ統合する。

---

## 9. トランザクション統合ガイド

1. **呼び出し側で一度だけ `db.transaction` を開始**し、その `tx` を `walletService.*(params, tx)` に渡す。
   ```ts
   await db.transaction(async (tx) => {
     await walletService.reserveBalance({ userId, walletType, amount }, tx);
     // 抽選や商品決定など中間処理
     await walletService.consumeReservedBalance({ userId, walletType, amount, sourceType: "user_action" }, tx);
   });
   ```
2. **単体で呼びたい場合**は `tx` を渡さなければ OK。内部で `db.transaction` が張られる。
3. **予約→確定**の組み合わせは `reserveBalance`/`consumeReservedBalance`、失敗時の解除は `releaseReservation` を使用。`meta` / `requestBatchId` を必ず引き継ぐとトレースしやすい。

---

## 10. 管理 API のリクエスト/レスポンス例

| 項目 | 内容 |
| --- | --- |
| エンドポイント | `POST /api/admin/wallet/{userId}/adjust` |
| Body 例 | ```json { "walletType": "regular_point", "changeMethod": "INCREMENT", "amount": 5000, "reason": "キャンペーン補填", "requestBatchId": "3db8...", "meta": { "orderId": "ORDER-1234", "notes": "特別対応" } } ``` |
| 成功レスポンス | `200 OK` + `{ wallet: { ...最新残高... }, history: { ...履歴レコード... } }` |
| エラー例 | `400`（Zodバリデーションエラー）, `403`（非管理者）, `409`（残高不足）, `500`（内部エラー） |

---

## 11. メタ情報とインデックス運用のヒント

- `meta` に追加したキーで検索したくなった場合は、`wallet_histories` に GIN インデックスを付与する。
  1. `src/features/core/walletHistory/entities/drizzle.ts` に `jsonb("meta").$type<WalletHistoryMeta>().default({})` を設定済み。
  2. 追加インデックスの例: `db.schema.sql`: `CREATE INDEX wallet_histories_meta_order_id_idx ON wallet_histories USING gin ((meta ->> 'orderId'));`
  3. `npm run db:generate` → `npm run db:push` で適用。
- `meta` のキー例: `productId`, `orderId`, `externalTransactionId`, `adminId`, `notes`。UI から渡す際もこのキー群を推奨。

---

## 12. 管理モーダル（AdminWalletAdjustModal）の操作フロー

1. 操作列の「ポイント操作」ボタンを押すとモーダルが開き、対象ユーザーの表示名／メール／残高（通常・期間限定）がカードで表示される。
2. 入力項目:
   - ウォレット種別（radio）
   - 操作方法（加算／減算／セット）
   - 金額（初期値なし。未入力で送信するとバリデーションエラー）
   - 理由（ユーザーに伝わるメッセージ）
   - 商品ID / 注文ID / 参照ID（任意）
   - 社内メモ（ユーザーには表示しない）
3. 送信成功でトースト「ポイントを更新しました」、失敗で `err()` 文言を表示。
4. `useAdjustWallet` が成功すると `wallets` SWR キーが再検証され、残高カードの表示も更新される。

---

## 13. デバッグ/トラブルシュート Q&A

- **Q. API 呼び出しで 500 が返る**
  A. サーバーログの `DomainError` を確認し、`walletService` で投げられたメッセージに従う。`Domain config not found: wallet` が出る場合は `schemaRegistry` と `domainConfig` の登録を確認。

- **Q. 「Route ... params is a Promise」 というエラー**
  A. Next.js 16 の API では `context.params` が Promise のため、`const { params } = await context` のように `await` が必要（このガイド内のサンプル参照）。

- **Q. 残高が更新されない／表示が古い**
  A. フロントで `useAdjustWallet` の `revalidateKeys` を適切に指定（`["wallets"]` など）しているか確認。SWR キャッシュキーとバックエンドのレスポンス整合を再チェック。

- **Q. 大量更新時のパフォーマンス**
  A. `meta` でよく検索するキーには GIN インデックスを追加。履歴テーブルの `request_batch_id` でまとまりを絞ってから更に `meta` で絞り込むと高速。

---

## 14. 購入リクエストの管理（purchase_requests）

### 背景と目的

リダイレクト型決済（Stripe Checkout、PayPay、コンビニ決済等）では、ユーザーが外部決済ページに遷移し、支払い完了後に戻ってくるまで「処理中」の状態を管理する必要がある。

`wallet_history` は「完了した残高変更」を記録するテーブルであり、以下の中間状態は表現できない：
- 決済ページに遷移中（ユーザーがまだ支払っていない）
- 支払い処理中（決済サービスが処理中）
- 支払い失敗（残高変更は発生しない）

そのため、購入リクエストの状態を管理する専用テーブル `purchase_requests` を導入する。

### purchase_requests テーブル構造

| フィールド | 型 | 説明 |
| --- | --- | --- |
| `id` | UUID | リクエストID（主キー） |
| `user_id` | UUID | 購入ユーザー |
| `idempotency_key` | VARCHAR | 冪等キー（UNIQUE制約、二重購入防止） |
| `wallet_type` | ENUM | 対象ウォレット種別（`regular_coin` 等） |
| `amount` | INTEGER | 購入数量（コイン数など） |
| `payment_amount` | INTEGER | 支払い金額（円） |
| `payment_method` | VARCHAR | 支払い方法（`credit_card` / `amazon_pay` / `convenience_store` / `bank_transfer`） |
| `status` | ENUM | `pending` → `processing` → `completed` / `failed` / `expired` |
| `payment_provider` | VARCHAR | 決済プロバイダ（`dummy` / `stripe` / `paypay` 等） |
| `payment_session_id` | VARCHAR | 外部決済サービスのセッションID（nullable） |
| `wallet_history_id` | UUID | 完了時に作成された wallet_history のID（nullable） |
| `error_code` | VARCHAR | エラー時のコード（nullable） |
| `error_message` | TEXT | エラー時の詳細メッセージ（nullable） |
| `created_at` | TIMESTAMP | 作成日時 |
| `updated_at` | TIMESTAMP | 更新日時 |
| `completed_at` | TIMESTAMP | 完了日時（nullable） |
| `expires_at` | TIMESTAMP | 有効期限（nullable、未完了リクエストの自動失効用） |

### ステータス遷移

```
┌─────────┐
│ pending │ ← 購入開始、決済セッション作成前
└────┬────┘
     │ 決済サービスにセッション作成
     ▼
┌────────────┐
│ processing │ ← ユーザーが決済ページで支払い中
└─────┬──────┘
      │
      ├─── 支払い成功（Webhook） ──→ ┌───────────┐
      │                              │ completed │ → wallet残高更新
      │                              └───────────┘
      │
      ├─── 支払い失敗（Webhook） ──→ ┌────────┐
      │                              │ failed │
      │                              └────────┘
      │
      └─── 有効期限切れ ───────────→ ┌─────────┐
                                     │ expired │
                                     └─────────┘
```

### wallet / wallet_history との関係

```
purchase_requests (1) ──→ (0..1) wallet_history
        │
        │ 完了時のみ履歴が作成される
        │
        └──→ wallet_history.request_batch_id = purchase_requests.id
             として紐付け可能
```

- `purchase_requests` は「購入の意図と状態」を管理
- `wallet_history` は「実際に発生した残高変更」を記録
- 両者は独立しており、購入が完了した場合のみ `wallet_history` にレコードが作成される

---

## 15. 決済フローの設計

### リダイレクト型決済の全体フロー

```
┌──────────────────────────────────────────────────────────────────────────┐
│ 1. ユーザーが購入ボタンを押す                                              │
│    └─→ POST /api/wallet/purchase/initiate                                │
│        ├─ idempotency_key で既存チェック（二重購入防止）                   │
│        ├─ purchase_request 作成（status: pending）                        │
│        └─ 決済プロバイダにセッション作成リクエスト                          │
├──────────────────────────────────────────────────────────────────────────┤
│ 2. 決済セッション作成完了                                                  │
│    └─→ purchase_request 更新（status: processing, payment_session_id）    │
│    └─→ クライアントに決済ページURLを返却                                   │
├──────────────────────────────────────────────────────────────────────────┤
│ 3. ユーザーが決済ページで支払い                                            │
│    └─→ 外部決済サービスのページにリダイレクト                              │
├──────────────────────────────────────────────────────────────────────────┤
│ 4. 支払い完了                                                             │
│    ├─→ Webhook: POST /api/webhook/payment                                │
│    │   ├─ payment_session_id で purchase_request を検索                   │
│    │   ├─ adjustBalance() でウォレット残高を更新                          │
│    │   └─ purchase_request 更新（status: completed, wallet_history_id）   │
│    │                                                                      │
│    └─→ リダイレクト: /coins?purchase_request_id=xxx                       │
│        └─ purchase_request の status を確認して結果表示                    │
└──────────────────────────────────────────────────────────────────────────┘
```

### 決済プロバイダの抽象化

将来的に複数の決済サービスに対応するため、共通インターフェースを定義する。

```typescript
// src/features/core/wallet/services/server/payment/types.ts

/** 決済セッション作成パラメータ */
type CreatePaymentSessionParams = {
  purchaseRequestId: string;
  amount: number;          // 支払い金額（円）
  userId: string;
  successUrl: string;      // 支払い成功時のリダイレクト先
  cancelUrl: string;       // キャンセル時のリダイレクト先
  metadata?: Record<string, string>;
};

/** 決済セッション */
type PaymentSession = {
  sessionId: string;       // 決済サービス側のセッションID
  redirectUrl: string;     // ユーザーをリダイレクトするURL
  expiresAt?: Date;        // セッションの有効期限
};

/** 決済結果 */
type PaymentResult = {
  success: boolean;
  sessionId: string;
  errorCode?: string;
  errorMessage?: string;
};

/** 決済プロバイダインターフェース */
interface PaymentProvider {
  readonly providerName: string;

  /** 決済セッションを作成 */
  createSession(params: CreatePaymentSessionParams): Promise<PaymentSession>;

  /** Webhookペイロードを検証・パース */
  parseWebhookPayload(request: Request): Promise<PaymentResult>;
}
```

### ダミー決済プロバイダ

開発・テスト用のダミー実装。即座に成功を返し、リダイレクトをシミュレートする。

```typescript
// src/features/core/wallet/services/server/payment/dummyProvider.ts

class DummyPaymentProvider implements PaymentProvider {
  readonly providerName = "dummy";

  async createSession(params: CreatePaymentSessionParams): Promise<PaymentSession> {
    // ダミー: 即座にセッションを作成
    const sessionId = `dummy_${params.purchaseRequestId}`;

    return {
      sessionId,
      // ダミー決済確認ページにリダイレクト
      redirectUrl: `/coins/purchase/confirm?session_id=${sessionId}`,
      expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30分
    };
  }

  async parseWebhookPayload(request: Request): Promise<PaymentResult> {
    // ダミー: リクエストボディからセッションIDを取得
    const body = await request.json();
    return {
      success: true,
      sessionId: body.sessionId,
    };
  }
}
```

### プロバイダの切り替え

環境変数またはリクエストパラメータで決済プロバイダを選択。

```typescript
// src/features/core/wallet/services/server/payment/index.ts

function getPaymentProvider(providerName: string): PaymentProvider {
  switch (providerName) {
    case "dummy":
      return new DummyPaymentProvider();
    case "stripe":
      return new StripePaymentProvider(); // 将来実装
    case "paypay":
      return new PayPayProvider();        // 将来実装
    default:
      throw new Error(`Unknown payment provider: ${providerName}`);
  }
}
```

---

## 16. 二重購入防止と冪等性

### 二重購入が発生するパターン

| パターン | 原因 | 対策レイヤー |
| --- | --- | --- |
| ダブルクリック | ユーザーがボタンを連打 | UI（ボタン無効化） |
| リロード | 決済中にページをリロード | API（冪等キー） |
| 戻るボタン | 完了後に戻って再送信 | API（冪等キー） |
| ネットワーク遅延 | タイムアウト後のリトライ | API（冪等キー） |
| Webhook重複 | 決済サービスからの複数通知 | DB（ステータスチェック） |
| 複数タブ | 同時に購入ページを開く | DB（UNIQUE制約） |

### 多層防御の実装

#### 1. UIレベル（補助的）

```tsx
// 購入ボタンのローディング状態
const [isSubmitting, setIsSubmitting] = useState(false);

<Button
  disabled={isSubmitting}
  onClick={handlePurchase}
>
  {isSubmitting ? "処理中..." : "購入する"}
</Button>
```

#### 2. APIレベル（冪等キー）

```typescript
// クライアント側: 購入開始時にUUIDを生成
const idempotencyKey = crypto.randomUUID();

// サーバー側: 同じキーのリクエストは既存を返す
async function initiatePurchase(params: InitiatePurchaseParams) {
  // 冪等キーで既存リクエストを検索
  const existing = await findPurchaseRequestByIdempotencyKey(params.idempotencyKey);

  if (existing) {
    // 既に処理済み or 処理中なら既存の結果を返す
    if (existing.status === "completed") {
      return { success: true, alreadyCompleted: true };
    }
    if (existing.status === "processing") {
      return { redirectUrl: existing.redirectUrl };
    }
    // pending の場合は再利用して続行
  }

  // 新規リクエスト作成
  // ...
}
```

#### 3. DBレベル（UNIQUE制約 + ステータス管理）

```sql
-- idempotency_key にUNIQUE制約
CREATE UNIQUE INDEX purchase_requests_idempotency_key_idx
  ON purchase_requests(idempotency_key);

-- ステータス更新時の楽観的ロック
UPDATE purchase_requests
SET status = 'completed', completed_at = NOW()
WHERE id = $1 AND status = 'processing'
RETURNING *;
-- 0行更新 = 既に別のリクエストで更新済み
```

#### 4. Webhookレベル（べき等処理）

```typescript
async function handlePaymentWebhook(payload: PaymentResult) {
  const purchaseRequest = await findByPaymentSessionId(payload.sessionId);

  // 既に完了済みなら何もしない（Webhook重複対策）
  if (purchaseRequest.status === "completed") {
    return { success: true, message: "Already processed" };
  }

  // ステータス更新（楽観的ロック）
  const updated = await updateStatusToCompleted(purchaseRequest.id);
  if (!updated) {
    // 競合発生 = 別のWebhookで既に処理済み
    return { success: true, message: "Processed by another request" };
  }

  // ウォレット残高更新
  await adjustBalance({
    userId: purchaseRequest.userId,
    walletType: purchaseRequest.walletType,
    changeMethod: "INCREMENT",
    amount: purchaseRequest.amount,
    sourceType: "user_action",
    requestBatchId: purchaseRequest.id,
    meta: { purchaseRequestId: purchaseRequest.id }
  });
}
```

### 冪等キーの有効期限

- 冪等キーは永続的に保持する必要はない
- 一定期間（例: 24時間）経過後は同じキーでも新規リクエストとして扱う
- `purchase_requests.expires_at` で管理し、バッチジョブで期限切れレコードを `expired` に更新

---

## 17. 購入フローの実装チェックリスト

### 購入開始時
- [ ] クライアントで冪等キー（UUID）を生成しているか
- [ ] 購入ボタンを押した直後にローディング状態にしているか
- [ ] `purchase_requests` に新規レコードを作成しているか
- [ ] 決済プロバイダにセッション作成をリクエストしているか

### 決済中
- [ ] ユーザーを適切な決済ページにリダイレクトしているか
- [ ] `purchase_requests.status` を `processing` に更新しているか
- [ ] `payment_session_id` を記録しているか

### Webhook受信時
- [ ] Webhookの署名検証をしているか（本番環境）
- [ ] `payment_session_id` で `purchase_requests` を検索しているか
- [ ] ステータスが `processing` の場合のみ処理しているか（べき等性）
- [ ] `adjustBalance` でウォレット残高を更新しているか
- [ ] `wallet_history_id` を記録しているか
- [ ] `purchase_requests.status` を `completed` に更新しているか

### 完了後
- [ ] ユーザーを成功ページにリダイレクトしているか
- [ ] トーストで購入完了を通知しているか
- [ ] 残高表示を更新しているか（SWR再検証）

### エラー処理
- [ ] 決済失敗時に `status` を `failed` に更新しているか
- [ ] エラーメッセージをユーザーに表示しているか
- [ ] 期限切れリクエストを定期的に `expired` に更新しているか

---

## 18. 連携時に参照すべきファイル（購入機能）

| 利用シーン | ファイル / 関数 | ポイント |
| --- | --- | --- |
| 購入リクエスト作成 | `src/features/core/wallet/services/server/purchase/initiatePurchase.ts` | 冪等キーチェック、purchase_request作成、決済セッション作成 |
| 決済プロバイダ | `src/features/core/wallet/services/server/payment/index.ts` | `getPaymentProvider()` でプロバイダを取得 |
| Webhook処理 | `src/app/api/webhook/payment/route.ts` | 決済完了通知の受信、ウォレット更新 |
| 購入完了確認 | `src/features/core/wallet/services/server/purchase/getPurchaseStatus.ts` | purchase_request のステータス取得 |
| UIコンポーネント | `src/features/core/wallet/components/UserBalance/`, `src/features/core/wallet/components/CurrencyPurchase/` | 残高表示、購入フォーム |
| 購入ページ | `src/app/(user)/(protected)/coins/page.tsx`, `src/app/(user)/(protected)/coins/purchase/page.tsx` | ユーザー向け画面 |

---
